(defpackage "TEST-SOLVE-SORT-CONSTRAINTS"
  (:use "CL" "PROVE")
  (:local-nicknames ("C" "CONDITION")
                    ("F" "FRESH")
                    ("S" "SKELETON-TYPE")
                    ("M" "MONO-TYPE")
                    ("P" "POLY-TYPE")))

(in-package "TEST-SOLVE-SORT-CONSTRAINTS")

(setf prove:*default-test-function* #'equalp)

(defun dump-flow-vars (solution)
  (and solution
       (let ((acc '()))
         (solve-sort-constraints:do-flow-vars
             ((var sort-or-null) solution (nreverse acc)
              :sort #'string<)
           (push (cons var sort-or-null) acc)))))

(plan 12)

;;; (a -> b) -> (b -> c) -> (a -> c)
(is (dump-flow-vars
     (solve-sort-constraints:solution
      (s:parse `(s:function ((s:function ((s:box (s:base f:b0 + (f:t0) :arg)))
                                         ((s:base f:b1 - (f:t1) :res)))
                             (s:function ((s:base f:b2 + (f:t1) :arg))
                                         ((s:base f:b3 - (f:t2) :res))))
                            ((s:function ((s:base f:b4 - (f:t0) :arg))
                                         ((s:base f:b5 + (f:t2) :res))))))
      (p:parse `(p:function ((p:function ((p:box (p:var (a))))
                                         ((p:var (b))))
                             (p:function ((p:var (b)))
                                         ((p:var (c)))))
                            ((p:function ((p:var (a)))
                                         ((p:var (c)))))))
      (m:parse `((m:function ((m:box (m:base integer c:true)))
                             ((m:base integer c:true)))
                 (m:function ((m:base integer c:true))
                             ((m:base integer c:true)))))
      (p:parse `((p:function ((p:var (d)))
                             ((p:var (e))))))))
    `((f:t0 . integer)
      (f:t1 . integer)
      (f:t2 . integer)))

(is (solve-sort-constraints:sort-or-null
     (solve-sort-constraints:solution
      (s:parse `(s:function ((s:function ((s:box (s:base f:b0 + (f:t0) :arg)))
                                         ((s:base f:b1 - (f:t1) :res)))
                             (s:function ((s:base f:b2 + (f:t1) :arg))
                                         ((s:base f:b3 - (f:t2) :res))))
                            ((s:function ((s:base f:b4 - (f:t0) :arg))
                                         ((s:base f:b5 + (f:t2) :res))))))
      (p:parse `(p:function ((p:function ((p:box (p:var (a))))
                                         ((p:var (b))))
                             (p:function ((p:var (b)))
                                         ((p:var (c)))))
                            ((p:function ((p:var (a)))
                                         ((p:var (c)))))))
      (m:parse `((m:function ((m:box (m:base integer c:true)))
                             ((m:base integer c:true)))
                 (m:function ((m:base integer c:true))
                             ((m:base integer c:true)))))
      (p:parse `((p:function ((p:var (d)))
                             ((p:var (e)))))))
     'f:t0)
    'integer)

;;; See what happens when the skeleton is missing some bindings
(is (solve-sort-constraints:solution
     (s:parse `(s:function ((s:function ((s:box (s:base f:b0 + (f:t0) :arg)))
                                        ((s:base f:b1 - (f:t1) :res)))
                            (s:function ((s:base f:b2 + (f:t1) :arg))
                                        ((s:base f:b3 - (f:t2) :res))))
                           ((s:function ((s:box (s:base f:b4 - (f:t3) :arg)))
                                        ((s:base f:b5 + (f:t2) :res))))))
     (p:parse `(p:function ((p:function ((p:box (p:var (a))))
                                        ((p:var (b))))
                            (p:function ((p:var (b)))
                                        ((p:var (c)))))
                           ((p:function ((p:var (a)))
                                        ((p:var (c)))))))
     (m:parse `((m:function ((m:box (m:base integer c:true)))
                            ((m:base integer c:true)))
                (m:function ((m:base integer c:true))
                            ((m:base integer c:true)))))
     (p:parse `((p:var (d)))))
    nil)

;;; same, with redundant constraints on polymorphic function and return.
(is (dump-flow-vars
     (solve-sort-constraints:solution
      (s:parse `(s:function ((s:function ((s:base f:b0 + (f:t0) :arg))
                                         ((s:base f:b1 - (f:t1) :res)))
                             (s:function ((s:base f:b2 + (f:t1) :arg))
                                         ((s:base f:b3 - (f:t2) :res))))
                            ((s:function ((s:base f:b4 - (f:t0) :arg))
                                         ((s:base f:b5 + (f:t2) :res))))))
      (p:parse `(p:function ((p:function ((p:base (a) integer nil))
                                         ((p:var (b))))
                             (p:function ((p:var (b)))
                                         ((p:var (c)))))
                            ((p:function ((p:var (a)))
                                         ((p:var (c)))))))
      (m:parse `((m:function ((m:base integer c:true))
                             ((m:base integer c:true)))
                 (m:function ((m:base integer c:true))
                             ((m:base integer c:true)))))
      (p:parse `((p:function ((p:base (d) integer nil))
                             ((p:base (e) * nil)))))))
    `((f:t0 . integer)
      (f:t1 . integer)
      (f:t2 . integer)))

;;; incompatible constraint on polymorphic function
(is (solve-sort-constraints:solution
     (s:parse `(s:function ((s:function ((s:base f:b0 + (f:t0) :arg))
                                        ((s:base f:b1 - (f:t1) :res)))
                            (s:function ((s:base f:b2 + (f:t1) :arg))
                                        ((s:base f:b3 - (f:t2) :res))))
                           ((s:function ((s:base f:b4 - (f:t0) :arg))
                                        ((s:base f:b5 + (f:t2) :res))))))
     (p:parse `(p:function ((p:function ((p:base (a) float nil))
                                        ((p:var (b))))
                            (p:function ((p:var (b)))
                                        ((p:var (c)))))
                           ((p:function ((p:var (a)))
                                        ((p:var (c)))))))
     (m:parse `((m:function ((m:base integer c:true))
                            ((m:base integer c:true)))
                (m:function ((m:base integer c:true))
                            ((m:base integer c:true)))))
     (p:parse `((p:function ((p:base (d) integer nil))
                            ((p:var (e)))))))
    nil)

;;; incompatible on return
(is (solve-sort-constraints:solution
     (s:parse `(s:function ((s:function ((s:base f:b0 + (f:t0) :arg))
                                        ((s:base f:b1 - (f:t1) :res)))
                            (s:function ((s:base f:b2 + (f:t1) :arg))
                                        ((s:base f:b3 - (f:t2) :res))))
                           ((s:function ((s:base f:b4 - (f:t0) :arg))
                                        ((s:base f:b5 + (f:t2) :res))))))
     (p:parse `(p:function ((p:function ((p:base (a) integer nil))
                                        ((p:var (b))))
                            (p:function ((p:var (b)))
                                        ((p:var (c)))))
                           ((p:function ((p:var (a)))
                                        ((p:var (c)))))))
     (m:parse `((m:function ((m:base integer c:true))
                            ((m:base integer c:true)))
                (m:function ((m:base integer c:true))
                            ((m:base integer c:true)))))
     (p:parse `((p:function ((p:base (d) float nil))
                            ((p:var (e)))))))
    nil)

;;; incompatible constraints in monotype.
(is (solve-sort-constraints:solution
     (s:parse `(s:function ((s:function ((s:base f:b0 + (f:t0) :arg))
                                        ((s:base f:b1 - (f:t1) :res)))
                            (s:function ((s:base f:b2 + (f:t1) :arg))
                                        ((s:base f:b3 - (f:t2) :res))))
                           ((s:function ((s:base f:b4 - (f:t0) :arg))
                                        ((s:base f:b5 + (f:t2) :res))))))
     (p:parse `(p:function ((p:function ((p:var (a)))
                                        ((p:var (b))))
                            (p:function ((p:var (b)))
                                        ((p:var (c)))))
                           ((p:function ((p:var (a)))
                                        ((p:var (c)))))))
     (m:parse `((m:function ((m:base integer c:true))
                            ((m:base integer c:true)))
                (m:function ((m:base float c:true))
                            ((m:base float c:true)))))
     (p:parse `((p:function ((p:var (d)))
                            ((p:var (e)))))))
    nil)

;;; incompatible shape in poly function type.
(is (solve-sort-constraints:solution
     (s:parse `(s:function ((s:function ((s:base f:b0 + (f:t0) :arg))
                                        ((s:base f:b1 - (f:t1) :res)))
                            (s:function ((s:base f:b2 + (f:t1) :arg))
                                        ((s:base f:b3 - (f:t2) :res))))
                           ((s:base f:b4 - (f:t0) :res))))
     (p:parse `(p:function ((p:function ((p:var (a)))
                                        ((p:var (b))))
                            (p:function ((p:var (b)))
                                        ((p:var (c)))))
                           ((p:function ((p:var (a)))
                                        ((p:var (c)))))))
     (m:parse `((m:function ((m:base integer c:true))
                            ((m:base integer c:true)))
                (m:function ((m:base integer c:true))
                            ((m:base integer c:true)))))
     (p:parse `((p:function ((p:var (d)))
                            ((p:var (e)))))))
    nil)

;;; incompatible monotypes.
(is (solve-sort-constraints:solution
     (s:parse `(s:function ((s:function ((s:base f:b0 + (f:t0) :arg))
                                        ((s:base f:b1 - (f:t1) :res)))
                            (s:function ((s:base f:b2 + (f:t1) :arg))
                                        ((s:base f:b3 - (f:t2) :res))))
                           ((s:function ((s:base f:b4 - (f:t0) :arg))
                                        ((s:base f:b5 + (f:t2) :res))))))
     (p:parse `(p:function ((p:function ((p:var (a)))
                                        ((p:var (b))))
                            (p:function ((p:var (b)))
                                        ((p:var (c)))))
                           ((p:function ((p:var (a)))
                                        ((p:var (c)))))))
     (m:parse `((m:function ((m:base integer c:true))
                            ((m:base integer c:true)))
                (m:function ((m:base integer c:true) (m:base float c:true))
                            ((m:base integer c:true)))))
     (p:parse `((p:function ((p:var (d)))
                            ((p:var (e)))))))
    nil)

;;; incompatible return type
(is (solve-sort-constraints:solution
     (s:parse `(s:function ((s:function ((s:base f:b0 + (f:t0) :arg))
                                        ((s:base f:b1 - (f:t1) :res)))
                            (s:function ((s:base f:b2 + (f:t1) :arg))
                                        ((s:base f:b3 - (f:t2) :res))))
                           ((s:function ((s:base f:b4 - (f:t0) :arg))
                                        ((s:base f:b5 + (f:t2) :res))))))
     (p:parse `(p:function ((p:function ((p:var (a)))
                                        ((p:var (b))))
                            (p:function ((p:var (b)))
                                        ((p:var (c)))))
                           ((p:function ((p:var (a)))
                                        ((p:var (c)))))))
     (m:parse `((m:function ((m:base integer c:true))
                            ((m:base integer c:true)))
                (m:function ((m:base integer c:true))
                            ((m:base integer c:true)))))
     (p:parse `((p:base (d) * nil))))
    nil)

;;; compatible return type if the mismatch is with a var.
(is (dump-flow-vars
     (solve-sort-constraints:solution
      (s:parse `(s:function ((s:function ((s:base f:b0 + (f:t0) :arg))
                                         ((s:base f:b1 - (f:t1) :res)))
                             (s:function ((s:base f:b2 + (f:t1) :arg))
                                         ((s:base f:b3 - (f:t2) :res))))
                            ((s:function ((s:base f:b4 - (f:t0) :arg))
                                         ((s:base f:b5 + (f:t2) :res))))))
      (p:parse `(p:function ((p:function ((p:var (a)))
                                         ((p:var (b))))
                             (p:function ((p:var (b)))
                                         ((p:var (c)))))
                            ((p:function ((p:var (a)))
                                         ((p:var (c)))))))
      (m:parse `((m:function ((m:base integer c:true))
                             ((m:base integer c:true)))
                 (m:function ((m:base integer c:true))
                             ((m:base integer c:true)))))
      (p:parse `((p:var (d))))))
    `((f:t0 . integer)
      (f:t1 . integer)
      (f:t2 . integer)))

;;; same, but now the var is in the polymorphic type
(is (dump-flow-vars
     (solve-sort-constraints:solution
      (s:parse `(s:function ((s:function ((s:base f:b0 + (f:t0) :arg))
                                         ((s:base f:b1 - (f:t1) :res)))
                             (s:function ((s:base f:b2 + (f:t1) :arg))
                                         ((s:base f:b3 - (f:t2) :res))))
                            ((s:function ((s:base f:b4 - (f:t0) :arg))
                                         ((s:base f:b5 + (f:t2) :res))))))
      (p:parse `(p:function ((p:function ((p:var (a)))
                                         ((p:var (b))))
                             (p:var (c)))
                            ((p:function ((p:var (a)))
                                         ((p:var (c)))))))
      (m:parse `((m:function ((m:base integer c:true))
                             ((m:base integer c:true)))
                 (m:function ((m:base integer c:true))
                             ((m:base integer c:true)))))
      (p:parse `((p:function ((p:var (d)))
                             ((p:var (e))))))))
    `((f:t0 . integer)
      (f:t1 . integer)
      (f:t2 . integer)))

(finalize)
