(defpackage "TEST-PATTERN-TO-POLY"
  (:use "CL" "PROVE")
  (:local-nicknames ("C" "CONDITION")
                    ("F" "FRESH")
                    ("IN" "PATTERN-TYPE")
                    ("OUT" "POLY-TYPE")
                    ("M" "MONO-TYPE")))

(in-package "TEST-PATTERN-TO-POLY")

(setf prove:*default-test-function* #'equalp)

(plan 6)

(let ((c:*counter* 0))
  (is (pattern-to-poly:convert (in:parse `(in:function ((in:base (a) c:* c:true))
                                                       ((in:base (a) c:* c:true))))
                               (m:parse `((m:base integer c:true))))
      (out:parse `(out:function ((out:base (a) c:* c:true))
                                ((out:base (a) c:* c:true))))))

(let ((c:*counter* 0))
  (is (pattern-to-poly:convert (in:parse `(in:function ((in:base (a) integer c:true))
                                                       ((in:base (a) c:* c:true))))
                               (m:parse `((m:base integer c:true))))
      (out:parse `(out:function ((out:base (a) integer c:true))
                                ((out:base (a) c:* c:true))))))

(let ((c:*counter* 0))
  (is (pattern-to-poly:convert (in:parse `(in:function ((in:var (a))
                                                        (in:var (b))
                                                        (in:spread (c))
                                                        (in:base (d) * nil))
                                                       ((in:var (a b d))
                                                        (in:spread (c)))))
                               (m:parse `((m:base integer c:true)
                                          (m:function () ())
                                          (m:function () ())
                                          (m:function () ())
                                          (m:base double-float c:true))))
      (out:parse `(out:function ((out:var (a))
                                 (out:var (b))
                                 (out:var (f:s0))
                                 (out:var (f:s1))
                                 (out:base (d) * nil))
                                ((out:var (a b d))
                                 (out:var (f:s0))
                                 (out:var (f:s1)))))))

(let ((c:*counter* 0))
  (is (pattern-to-poly:convert (in:parse `(in:function ((in:function () ((in:spread (a))))
                                                        (in:function () ((in:spread (b)))))
                                                       ((in:spread (a b)))))
                               (m:parse `((m:function () ((m:base integer c:true)))
                                          (m:function () ((m:base integer c:true))))))
      (out:parse `(out:function ((out:function () ((out:var (f:s0))))
                                 (out:function () ((out:var (f:s1)))))
                                ((out:var (f:s0 f:s1)))))))

(let ((c:*counter* 0))
  (is (pattern-to-poly:convert (in:parse `(in:function ((in:function () ((in:spread (a))))
                                                        (in:function () ((in:spread (a)))))
                                                       ((in:spread (a)))))
                               (m:parse `((m:function () ((m:base integer c:true)))
                                          (m:function () ((m:base integer c:true))))))
      (out:parse `(out:function ((out:function () ((out:var (f:s0))))
                                 (out:function () ((out:var (f:s0)))))
                                ((out:var (f:s0)))))))

(let ((c:*counter* 0))
  (is (pattern-to-poly:convert (in:parse `(in:function ((in:box
                                                         (in:function ((in:spread (a)))
                                                                      ((in:spread (b)))))
                                                        (in:function ((in:spread (b)))
                                                                     ((in:spread (c)))))
                                                       ((in:box
                                                         (in:function ((in:spread (a)))
                                                                      ((in:spread (c))))))))
                               (m:parse `((m:box
                                           (m:function ((m:base integer c:true))
                                                       ((m:base integer (= c:v (+ (@- 0) 1))))))
                                          (m:function ((m:base integer c:true))
                                                      ((m:base integer (= c:v (- (@- 0) 1))))))))
      (out:parse `(out:function ((out:box
                                  (out:function ((out:var (f:s0)))
                                                ((out:var (f:s1)))))
                                 (out:function ((out:var (f:s1)))
                                               ((out:var (f:s2)))))
                                ((out:box
                                  (out:function ((out:var (f:s0)))
                                                ((out:var (f:s2))))))))))

(finalize)
